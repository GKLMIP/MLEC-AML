from __future__ import print_function
from six.moves import xrange
import six.moves.cPickle as pickle

import gzip
import os
import numpy

def prepare_data(seqs, labels, maxlen, traindata, index):
    """Create the matrices from the datasets.

    This pad each sequence to the same lenght: the lenght of the
    longuest sequence or maxlen.

    if maxlen is set, we will cut all sequence to this maximum
    lenght.

    This swap the axis!
    """
    # x: a list of sentences
    lengths = [len(s) for s in seqs]

    if maxlen is not None:
        new_seqs = []
        new_labels = []
        new_lengths = []
        for l, s, y in zip(lengths, seqs, labels):
            # print(l,s,y)
            if l <= maxlen:
                new_seqs.append(s)
                new_labels.append(y)
                new_lengths.append(l)
            else:
                new_seqs.append(s[:maxlen])
                new_labels.append(y)
                new_lengths.append(maxlen)
        print(len(new_seqs))
        lengths = new_lengths
        labels = new_labels
        seqs = new_seqs

        # if len(lengths) < 1:
        #     return None, None, None
    n_samples = len(seqs)
    #maxlen = numpy.max(lengths)
    x = numpy.zeros((maxlen, n_samples)).astype('int64')
    print(labels[0])
    labels = numpy.array(labels).astype('int32')
    print(labels[0])
    for idx, s in enumerate(seqs):
        x[:lengths[idx], idx] = s
    if not traindata:
        return [x, numpy.array(lengths).astype('int32'), labels]
    else:
        return [x, numpy.array(lengths).astype('int32'), labels, numpy.array(range(len(lengths))), [index]*len(lengths)]

def load_data(path, n_words=10000, valid_portion=0.125, maxlen=None,
    sort_by_len=False):

    if path.endswith(".gz"):
        f = gzip.open(path, 'rb')
    else:
        f = open(path, 'rb')

    train_set, test_set, valid_set= pickle.load(f)
    # for i in train_set:
    #     print(i)
    # f.close()
    # if maxlen:
    #     new_train_set_x = []
    #     new_train_set_y = []
    #     for x, y in zip(train_set[0], train_set[1]):
    #         print(x)
    #         if len(x) <= maxlen:
    #             new_train_set_x.append(x)
    #             new_train_set_y.append(y)
    #         else:
    #             new_train_set_x.append(x[:maxlen])
    #             new_train_set_y.append(y)
    #     print(len(new_train_set_x))
    #     train_set = (new_train_set_x, new_train_set_y)
    #     del new_train_set_x, new_train_set_y
    #
    # # split training set into validation set
    # train_set_x, train_set_y = train_set
    # n_samples = len(train_set_x)
    # sidx = numpy.random.permutation(n_samples)
    # n_train = int(numpy.round(n_samples * (1. - valid_portion)))
    # valid_set_x = [train_set_x[s] for s in sidx[n_train:]]
    # valid_set_y = [train_set_y[s] for s in sidx[n_train:]]
    # train_set_x = [train_set_x[s] for s in sidx[:n_train]]
    # train_set_y = [train_set_y[s] for s in sidx[:n_train]]
    #
    # train_set = (train_set_x, train_set_y)
    # valid_set = (valid_set_x, valid_set_y)

    def remove_unk(x):
        return [[1 if w >= n_words else w for w in sen] for sen in x]

    test_set_x, test_set_y = test_set
    valid_set_x, valid_set_y = valid_set
    train_set_x, train_set_y = train_set

    train_set_x = remove_unk(train_set_x)
    valid_set_x = remove_unk(valid_set_x)
    test_set_x = remove_unk(test_set_x)

    def len_argsort(seq):
        return sorted(range(len(seq)), key=lambda x: len(seq[x]))

    if sort_by_len:
        sorted_index = len_argsort(test_set_x)
        test_set_x = [test_set_x[i] for i in sorted_index]
        test_set_y = [test_set_y[i] for i in sorted_index]

        sorted_index = len_argsort(valid_set_x)
        valid_set_x = [valid_set_x[i] for i in sorted_index]
        valid_set_y = [valid_set_y[i] for i in sorted_index]

        sorted_index = len_argsort(train_set_x)
        train_set_x = [train_set_x[i] for i in sorted_index]
        train_set_y = [train_set_y[i] for i in sorted_index]

    train = [train_set_x, train_set_y]
    valid = [valid_set_x, valid_set_y]
    test = [test_set_x, test_set_y]

    return train, valid, test